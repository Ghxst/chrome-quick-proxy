document.addEventListener("DOMContentLoaded", () => { const $ = i => document.getElementById(i), h = $("host"), p = $("port"), u = $("user"), w = $("pass"), c = $("webrtc"), y = $("save"), g = $("clear"), b = $("harBtn"), x = $("harFile"), m = $("harControls"), v = $("entrySelect"), S = $("sideSelect"), I = $("importCookies"), N = $("sessionBtn"), E = $("exportBtn"), J = $("importJsonBtn"), K = $("importJsonNoneBtn"), F = $("importJsonFile"); chrome.storage.sync.get(["host", "port", "username", "password", "webrtc"], d => { d.host && (h.value = d.host); d.port && (p.value = d.port); d.username && (u.value = d.username); d.password && (w.value = d.password); d.webrtc && (c.value = d.webrtc) }); const L = (e, o) => chrome.runtime.sendMessage(e, o), R = e => new Promise((o, r) => chrome.cookies.set(e, () => chrome.runtime.lastError ? r(chrome.runtime.lastError) : o())), T = (e, o) => { const t = (e.domain || new URL(o).hostname).replace(/^\./, ""); return (e.secure ? "https://" : "http://") + t + (e.path || "/") }; y.addEventListener("click", () => { const e = { host: h.value.trim(), port: Number(p.value.trim()), username: u.value.trim(), password: w.value }; if (!e.host || !e.port) return alert("Host and port required."); L({ action: "setAll", data: { proxy: e, webrtc: c.value } }, o => { chrome.runtime.lastError || o?.ok === !1 ? alert(chrome.runtime.lastError?.message || o?.error || "Error") : window.close() }) }); g.addEventListener("click", () => L({ action: "clearAll" }, o => { chrome.runtime.lastError || o?.ok === !1 ? alert(chrome.runtime.lastError?.message || o?.error || "Error") : window.close() })); let d = []; b.addEventListener("click", () => x.click()); x.addEventListener("change", () => { if (!x.files.length) return; const e = new FileReader; e.onload = i => { try { const o = JSON.parse(i.target.result); d = o?.log?.entries || []; if (!d.length) throw 0; v.innerHTML = d.map((s, l) => `<option value="${l}">${l + 1} â€” ${s.request.method} ${s.request.url}</option>`).join(""); m.style.display = "block" } catch { alert("HAR error"); d = []; m.style.display = "none" } }; e.readAsText(x.files[0]) }); I.addEventListener("click", async () => { const e = d[Number(v.value)]; if (!e) return alert("No entry."); const o = e[S.value]?.cookies || []; if (!o.length) return alert("No cookies."); let r = 0; for (const s of o) try { await R({ url: T(s, e.request.url), name: s.name, value: s.value, domain: s.domain, path: s.path || "/", secure: !!s.secure, httpOnly: !!s.httpOnly, expirationDate: s.expires ? Number(s.expires) : undefined }); r++ } catch { } alert(`Imported ${r}/${o.length} cookies`) }); N.addEventListener("click", async () => { const e = prompt("Paste session JSON"); if (!e) return; let o; try { o = JSON.parse(e) } catch { return alert("Invalid JSON") }; const r = o.cookies || []; if (!r.length) return alert("No cookies field."); let s = 0; for (const l of r) if (l.name && l.value && l.domain) try { await R({ url: T(l, "https://" + l.domain.replace(/^\./, "")), name: l.name, value: l.value, domain: l.domain, path: l.path || "/", secure: !!l.secure, httpOnly: !!l.httpOnly, expirationDate: l.expires ? Number(l.expires) : undefined }); s++ } catch { } alert(`Loaded ${s}/${r.length} cookies`) }); E.addEventListener("click", () => { if (!confirm("Warning: this will export ALL cookies stored in Chrome, not just for the current site. Continue?")) return; chrome.cookies.getAll({}, e => { const o = new Blob([JSON.stringify(e)], { type: "application/json" }), r = URL.createObjectURL(o), s = document.createElement("a"); s.href = r; s.download = "cookies_" + Date.now() + ".json"; s.click(); URL.revokeObjectURL(r) }) }); let H = !1; J.addEventListener("click", () => { H = !1; F.click() }); K.addEventListener("click", () => { H = !0; F.click() }); F.addEventListener("change", () => { if (!F.files.length) return; const e = new FileReader; e.onload = async i => { let o; try { o = JSON.parse(i.target.result) } catch { return alert("Invalid JSON") }; if (!Array.isArray(o) || !o.length) return alert("No cookies array."); let r = 0; for (const s of o) if (s.name && s.value && s.domain) try { await R({ url: T(s, "https://" + s.domain.replace(/^\./, "")), name: s.name, value: s.value, domain: s.domain, path: s.path || "/", secure: !!s.secure, httpOnly: !!s.httpOnly, sameSite: H ? "no_restriction" : s.sameSite, expirationDate: s.expirationDate ?? (s.expires ? Number(s.expires) : undefined) }); r++ } catch { } alert(`Imported ${r}/${o.length} cookies`) }; e.readAsText(F.files[0]) }) });
