let a = null; async function e() { a && (chrome.webRequest.onAuthRequired.removeListener(a), a = null); return new Promise(r => chrome.proxy.settings.clear({ scope: "regular" }, r)) } async function t(o) { await e(); const i = { mode: "fixed_servers", rules: { singleProxy: { scheme: "http", host: o.host, port: Number(o.port) }, bypassList: ["localhost", "127.0.0.1", "::1"] } }; await new Promise(r => chrome.proxy.settings.set({ value: i, scope: "regular" }, r)); o.username && o.password && (a = d => d.isProxy ? { authCredentials: { username: o.username, password: o.password } } : { cancel: !0 }, chrome.webRequest.onAuthRequired.addListener(a, { urls: ["<all_urls>"] }, ["blocking"])) } const n = chrome.privacy.network.webRTCIPHandlingPolicy; const s = o => new Promise((r, l) => n.set({ value: o, scope: "regular" }, () => chrome.runtime.lastError ? l(chrome.runtime.lastError) : r())); chrome.runtime.onMessage.addListener((o, r, l) => { (async () => { try { if (o.action === "setAll") { await Promise.all([t(o.data.proxy), s(o.data.webrtc)]); chrome.storage.sync.set({ ...o.data.proxy, webrtc: o.data.webrtc }) } else if (o.action === "clearAll") { await Promise.all([e(), s("default")]); chrome.storage.sync.clear() } else throw new Error("bad action"); l({ ok: !0 }) } catch (c) { l({ ok: !1, error: c.message }) } })(); return !0 });
